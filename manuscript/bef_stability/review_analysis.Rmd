---
title: "Analyse from review"
output: bookdown::html_document2
---

```{r, message = FALSE, results = FALSE, echo = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  message = FALSE,
  comment = "#>",
  cache = TRUE,
  echo = FALSE,
  warning = FALSE,
  warnings = FALSE
)
#knitr::opts_chunk$get()
```


```{r}
mypath <- rprojroot::find_package_root_file

library(tidyverse)
library(cowplot)
library(magrittr)

source(mypath("R", "misc.R"))
source_dir(mypath("R"))

theme_set(theme_cowplot())

myload(sem_data, synchrony, dir = mypath("data"))
```

# Response to the comment R1-5

We check that $CV_{com, i} = \overline{CV_{sp, i}} \times \sqrt{\phi_i}$

```{r}
p_sync <- synchrony %>%
  ggplot(aes(y = cv_sp * sqrt(synchrony), x = cv_classic)) +
  geom_point() +
  labs(y = "CVsp * sqrt(synchrony)", x = "CV of biomass")
```




# Response to the comment R3-1

```{r, echo = TRUE}
mod <- lm(log_stab_std ~ 0 + log_cv_sp + log_sync, data = sem_data)

#summary(mod)
coefs <- broom::tidy(mod) %>%
  select(term, estimate)

coefs %<>%
  mutate(
    sd = map_dbl(term, ~sd(sem_data[[.x]])),
    coef_std = (estimate * sd) / sd(sem_data$log_stab_std)
  )

# Standard deviation according to Olivier et al. (2020):
sd(log(1 / sem_data$sync))
sd(log(1 / sem_data$cv_sp))
mod_olivier <- lm(I(-log(bm_std_stab)) ~ 0 + I(-log(cv_sp)) + I(-log(sync)), data = sem_data)
broom::tidy(mod_olivier)

```

# Response to the comment 

```{r}
source(mypath("R", "synchrony.R"))

myload(community_analysis, op_analysis, synchrony, dir = mypath("data"))

myload(network_metrics, network_analysis, dir = mypath("data", "classes"))
```


```{r}
compute_pair_synchrony <- function (com_mat = NULL) {
  sp_names <- colnames(com_mat)
  ti <- combn(sp_names, 2,
    FUN = function (x) {
      covar <- cov(x = com_mat[, x[1:2]])
      #  vars <- var(c(mat[, x[1]], mat[, x[2]])) 
      sync <- compute_synchrony(covar)
      names(sync) <- paste(x[1], x[2], sep = "-")
      return(sync)
    }, simplify = FALSE
  )
  unlist(ti)
}
```


```{r}

net <- left_join(network_metrics, op_analysis, by = "opcod") %>%
  ungroup() %>%
  filter(!is.na(station))

prep_troph_sp_biomass <- net %>%
  select(opcod, station, year, composition, surface) %>%
  unnest(composition) %>%
  mutate(bm_std = biomass/ surface)

troph_sp_biomass <- prep_troph_sp_biomass %>%
  select(station, year, sp_class, bm_std) %>%
  group_by(station) %>%
  nest() %>%
  mutate(
    com_mat = map(data, function(x) {
      ti <- x %>%
	pivot_wider(names_from = sp_class, values_from = bm_std) %>%
	mutate_at(vars(matches("[A-Z]{3}", ignore.case = FALSE)),
	  ~ifelse(is.na(.), 0, .))
    return(as.matrix(select(ti, -year)))
}
    )
  )
  
library(furrr)
library(parallel)
plan(multisession, workers = 3)

sync_troph_sp <- troph_sp_biomass %>%
  ungroup() %>% # For furrr to works
  mutate(sync = future_map(com_mat, ~compute_pair_synchrony(.x)))

```

```{r}
get_if_fish_pair_interact <- function (net = NULL) {

  te <- net[
    str_detect(colnames(net), "[A-Z]{3}"),
    str_detect(colnames(net), "[A-Z]{3}")
    ]

  sp_names <- colnames(te)
  ti <- combn(sp_names, 2,
    FUN = function (x) {
      int <- as.logical(te[x[2], x[1]])
      names(int) <- paste(x[1], x[2], sep = "-")
      return(int)
    }, simplify = FALSE
  )
  unlist(ti)
}
```


```{r}
myload(metaweb_analysis, dir = mypath("data"))
metaweb <- metaweb_analysis$metaweb

```

```{r}

pair_int <- get_if_fish_pair_interact(metaweb)
metaweb["ANG_2", "TRF_8"]


```

```{r}
get_sync_int <- function(sync = NULL, pair_int = NULL) {

  # compute inv prey-pred names to have symetric name combination   
  pair_site <- names(sync)
  inv_pair_site <- str_split(pair_site, "-") %>% map_chr(., ~paste0(.x[2], "-",.x[1]))

  tmp <- pair_int[c(pair_site, inv_pair_site)]
  pair_int_com <- tmp[!is.na(tmp)]

  replace_pair_inv_pair <-  pair_site
  names(replace_pair_inv_pair) <- inv_pair_site 
  names(pair_int_com) <- str_replace_all(names(pair_int_com), replace_pair_inv_pair)

  df_pair <- enframe(pair_int_com, name = "pair", value = "interact")
  df_sync <- enframe(sync, name = "pair", value = "sync")

  df_sync %<>%
    left_join(df_pair, by = "pair")

  return(df_sync)
}
```


```{r}

pair_site <- names(sync_troph_sp$sync[[1]])
inv_pair_site <-str_split(pair_site, "-") %>% map_chr(., ~paste0(.x[2], "-",.x[1]))
tmp <- pair_int[c(pair_site, inv_pair_site)]
pair_int_com <- tmp[!is.na(tmp)]


get_sync_int(sync_troph_sp$sync[[1]], pair_int = pair_int)

```

```{r, eval=FALSE}
sync_troph_sp %<>%
  mutate(sync_int = future_map(sync, get_sync_int, pair_int = pair_int))

sync_pair_int <- sync_troph_sp %>%
  select(station, sync_int) %>%
  unnest(sync_int)

mysave(sync_pair_int, dir = mypath("data"), overwrite = TRUE)
```

```{r}
myload(sync_pair_int, dir = mypath("data"))
sync_pair_int2 <- sync_pair_int %>%
  separate(pair, c("sp1", "sp2"), "-") %>%
  mutate_at(c("sp1", "sp2"), ~str_extract(., "[A-Z]{3}")) %>%
  mutate(cannibalism = map2_lgl(sp1, sp2, ~ifelse(.x == .y, TRUE, FALSE)))
```

There is no cannibalism case! 

```{r}
sync_pred <- sync_pair_int2 %>%
  ggplot(aes(y = sync, x = as.factor(interact)), fill = as.factor(cannibalism)) +
  geom_boxplot() +
  facet_grid(~cannibalism) +
  labs(y = "Synchrony", x = "Species in interaction", fill = "Cannibalism")
```

```{r}
sync_pred <- sync_pair_int2 %>%
  ggplot(aes(y = sync, x = as.factor(interact))) +
  geom_boxplot() +
  labs(y = "Synchrony", x = "Species pairs in interaction", fill = "Cannibalism")
```

```{r}
save_plot(file = mypath(
      "manuscript", "bef_stability", "result", 
      "synchrony_species_pairs.png"),
    plot = sync_pred,
    base_height = 2.5, base_asp = 1.2#1.618 
    )
```

# Response to the comment R3-L231 


```{r}
myload(op_analysis, dir = mypath("data"))

# station used in sem_data
op <- op_analysis %>%
  filter(station %in% sem_data$station)

## Combien de station par annÃ©e
op %>%
  group_by(year) %>%
  summarise(n = n()) %>% 
  ggplot(aes(x = year, y = n)) +
  geom_bar(stat = "identity")
```

```{r, fig.cap=""}
match_op_temp_data <- op %>%
  group_by(station) %>%
  summarise(
    year_temp = length(which(year %in% seq(2006, 2018))),
    year_temp_percent = length(which(year %in% seq(2006, 2018))) / n()
  )

match_op_temp_data %>%
  ggplot(aes(x = year_temp)) +
  geom_histogram() +
  labs(y = "Frequency", x = "Nb year of overlap between sampling and temperature time series")

match_op_temp_data %>%
  ggplot(aes(x = year_temp_percent)) +
  geom_histogram() +
  labs(y = "Frequency", x = "Percent of sampling years which overlaps with temperature time series")
```

```{r}
library(nlme)

myload(biomass_ts_sax, habitat_pressure, dir = mypath("data"))
myload(network_metrics, dir = mypath("data", "classes"))

# Get op only from 2006: 
op_analysis_bbb <- filter(op_analysis, station %in%
  biomass_ts_sax[biomass_ts_sax$sax == "bbb",]$station)
op_analysis_bbb_start_2006 <- op_analysis_bbb %>%
  filter(year >= 2006) 
# Select station followed 10 years or more
op_analysis_bbb_start_2006 %<>%
  group_by(station) %>%
  filter(n() >= 10) %>%
  ungroup()


st_basin <- get_basin_station()


sem_data_2006 <- compute_sem_dataset_from_op(
  .op = op_analysis_bbb_start_2006,
  habitat_pressure = habitat_pressure,
  st_basin = st_basin
)

stab_sem_rich_2006 <- compute_stab_sem_rich(
  .data = sem_data_2006,
  random_effect = as.formula("~1|basin")
)
stab_sem_rich <- compute_stab_sem_rich(
  .data = sem_data,
  random_effect = as.formula("~1|basin")
)
data_sensivity_2006 <- list(
  full = sem_data,
  from_2006 = sem_data_2006 
)

nb_station <- map_int(data_sensivity_2006, ~length(unique(.x$station)))
```

```{r stab}
stab_sensivity_2006 <- 
  map(data_sensivity_2006,
    ~compute_stab_sem_rich(
      .data = .x,
      random_effect = as.formula("~1|basin")
    )
  )

sem_stab_results_2006 <- map(stab_sensivity_2006,
  ~.x$coefficients[-ncol(.x$coefficients)]) %>%
  enframe() %>%
  rename(dataset = name) %>%
  unnest(value)


# Reformat
colnames(sem_stab_results_2006) <- str_to_lower(colnames(sem_stab_results_2006))

p_sens_stab <- plot_sensivity_analysis(
  .data = sem_stab_results_2006,
  inverse_label_order = TRUE, 
  y_lim = c(-1.5, .75), pval = TRUE
  ) +
scale_color_manual(
  values = c("full" = "red", "from_2006" = "blue"),
  labels = c("Full dataset", "Dataset from 2006"),
  breaks = c("full", "from_2006") 
  ) +
  guides(color = guide_legend(direction = "horizontal", nrow = 1)) +
  theme(legend.position = "bottom", plot.margin = unit(c(0, 0, 0, 25), units = "mm"))+
  labs(shape = "P <= 0.05")
```

```{r}
save_plot(file = mypath(
      "manuscript", "bef_stability", "result", 
      "sensivity_stab_2006.png"),
    plot = p_sens_stab,
    base_height = 9, base_asp = 1.2#1.618 
    )
```


```{r}
bm_sensivity_2006 <- 
  map(data_sensivity_2006,
    ~compute_prod_sem_rich(
      .data = .x,
      random_effect = as.formula("~1|basin")
    )
  )
sem_bm_results_2006 <- map(bm_sensivity_2006,
  ~.x$coefficients[-ncol(.x$coefficients)]) %>%
  enframe() %>%
  rename(dataset = name) %>%
  unnest(value)


# Reformat
colnames(sem_bm_results_2006) <- str_to_lower(colnames(sem_bm_results_2006))

p_sens_bm <- plot_sensivity_analysis(
  .data = sem_bm_results_2006,
  inverse_label_order = TRUE,
  y_lim = c(-1.5, .75), pval = TRUE
  ) +
scale_color_manual(
  values = c("full" = "red", "from_2006" = "blue")
  ) +
  guides(color = guide_legend(direction = "horizontal", nrow = 1)) +
  theme(legend.position = "bottom", plot.margin = unit(c(0, 0, 0, 25), units = "mm"))+
  labs(shape = "P <= 0.05")
```

```{r}
save_plot(file = mypath(
      "manuscript", "bef_stability", "result", 
      "sensivity_bm_2006.png"),
    plot = p_sens_bm,
    base_height = 9, base_asp = 1.2#1.618 
    )
```

```{r start-sens, fig.dim = c(10, 14), fig.cap="Sensivity of standardized estimate to the station starting date."}
legend_b <- get_legend(p_sens_stab)

p <- plot_grid(
  p_sens_bm %<>% + theme(legend.position = "none", plot.margin = unit(c(0,0,0,27), units = "mm")),
  p_sens_stab %<>% + theme(legend.position = "none", plot.margin = unit(c(0,0,0,27), units = "mm")),
  legend_b, nrow = 3,
  rel_heights = c(1, 1, .1),
  labels = c("Total biomass", "Biomass stability")
)
p
save_plot(
  file = mypath( "manuscript", "bef_stability", "result", 
      "sensivity_2006.png"),
    plot = p,
    nrow = 2,
    base_height = 9, base_asp = 1.6#1.618 
)
```

# Second answer

- get air temperature data 
- match them with water temperature (raw or interpolated?) 

```{r}
#devtools::install_github("RetoSchmucki/climateExtract")
library(climateExtract)
library(ncdf4)

fr_border <- sf::st_as_sf(raster::getData("GADM", country = "FRA", level = 0))
debug(extract_nc_value)
climate_data = extract_nc_value(first_year = 1995, 
                                last_year = 2018,
                                local_file = FALSE,
                                file_path = NULL,
                                sml_chunk = "2011-2020",
                                spatial_extent = fr_border,
                                clim_variable = "mean temp",
                                statistic = "mean",
                                grid_size = 0.25,
                                ecad_v = NULL,
                                write_raster = TRUE,
                                out = "raster_mean_temp.grd",
                                return_data = TRUE)
# Get annual mean for each point 
annual_avg_temp_pnts = temporal_aggregate(x = rbk,
                                          y = sf_point,
                                          agg_function = "mean",
                                          variable_name = "average temp",
                                          time_step = "annual")
```

```{r}
library(reprex)
library(climateExtract)
climate_data = extract_nc_value(first_year = 2012, 
                                last_year = 2015,
                                local_file = FALSE,
                                file_path = NULL,
                                sml_chunk = "2011-2020",
                                spatial_extent = fr_border,
                                clim_variable = "mean temp",
                                statistic = "mean",
                                grid_size = 0.25,
                                ecad_v = NULL,
                                write_raster = TRUE,
                                out = "raster_mean_temp.grd",
                                return_data = TRUE)
```

```{r}
library(climate)

po <- nearest_stations_ogimet(country = "France",
  date = Sys.Date(),
  add_map = TRUE,
  no_of_stations = 500 
)

o = meteo_ogimet(date = c("1995-01-01", "2018-12-31"), 
                 interval = "daily",
                 coords = FALSE, 
                 station = "07005")
```

```{r}
library(ncdf4)
library(raster)
library(sf)
cru_file <- list.files(mypath("data-raw", "cru"))[!str_detect(list.files(mypath("data-raw", "cru")), "gz")]
nc.pre <- nc_open(mypath("data-raw", "cru", "cru_ts4.03.2011.2018.tmp.dat.nc"))

l <- map(cru_file, function (x) {
  pre <- raster::brick(mypath("data-raw", "cru", x), varname="tmp")
  extract(pre, st_wgs)
		 }
)

tmean <- do.call(cbind, l)
rownames(tmean) <- st_wgs$station
colnames(tmean) <- paste0(rep(c(paste0(0, seq(1,9)), seq(10, 12)), 2018 - 1991), "_", rep(seq(1991, 2018), each = 12)) 


# Correlation mean air temperature / water temperature
air_mean_temp <-
  rowMeans(tmean[, which(colnames(tmean) == "01_1995"):which(colnames(tmean) == "12_2018")]) 
air_temp <- enframe(air_mean_temp, name = "station", value = "air_95_18") %>%
  mutate(
    station = as.integer(station),
    air_06_18 = rowMeans(
      tmean[, which(colnames(tmean) == "01_2006"):which(colnames(tmean) == "12_2018")]
    )
  )

myload(habitat_press, sem_data, dir = mypath("data"))
temp_avg_comp <- habitat_press %>%
  dplyr::select(station, temperature_med) %>%
  left_join(air_temp, by = "station") %>%
  rename(water_06_2018 = temperature_med) %>%
  filter(station %in% sem_data$station)


dev.new(width = 6, height = 6, units = "cm")
# i3: mod + shift + space 
png(
  file = mypath("manuscript", "bef_stability", "figs",
    "pairs_temperature_plot.png")
)
pairs(
  temp_avg_comp[, 2:4], pch = 19 
)
dev.off()

mat <- round(cor(temp_avg_comp[, 2:4]), 3)
write.table(mat,
  file = mypath("manuscript", "bef_stability", "result", "cor_mat_temp.txt"),
  sep = ",",
  quote = FALSE,
  row.names = T)

# Test with monthly data
myload(yearly_temp_press_interp_mv_avg, dir = mypath("data-raw", "temp"))
temp <- yearly_temp_press_interp_mv_avg %>%
  group_by(id, year) %>%
  arrange(value.predSE) %>%
  slice(1) %>%
  select(station = id, year, temp = value_corrected) %>%
  mutate(temp = ifelse(temp > 45, NA, temp)) %>%
  ungroup()

#plot(pre[[1]])
#
#uk.area <- extent(-12, 4, 48, 64)
#uk <- crop(pre, uk.area)
#plot(uk)
#st <- get_basin_station(sf =TRUE)
#st_wgs <- st_transform(st, crs = 4326)
#
#test <- extract(pre, st_wgs)
```



## L180-182

```{r}
myload(community_metrics, community_analysis,
  sem_data , dir = mypath("data"))
ti <- get_sync_cv_mat(com_analysis = community_analysis,
    op_analysis = op_analysis, presence_threshold = NA)

test <- ti %>%
  mutate(
    richness_tot = map_dbl(com_mat, ~ncol(.x)),
  ) %>%
select(station, richness_tot)
surf <- op_analysis %>%
  filter(station %in% sem_data$station) %>%
  group_by(station) %>%
  summarise(tot_surface = sum(surface), avg_surface = mean(surface))

surf_rich_tot <- surf %>%
  left_join(test, by = "station")

p_linear <- surf_rich_tot %>%
  ggplot(aes(x = tot_surface, y = (richness_tot))) +
  geom_point() +
  labs(y = "Total species richness", x = "Total surface (m^2)") +
  geom_smooth(method = "lm")
```

```{r}
test <- glm(richness_tot ~ tot_surface + I(tot_surface^2), family=quasipoisson, surf_rich_tot)
broom::tidy(test) %>%
  knitr::kable(, format = "rst")

```


```{r}
save_plot(file = mypath(
      "manuscript", "bef_stability", "result", 
      "richness_surface.png"),
    plot = p_linear,
    base_height = 9, base_asp = 1.2#1.618 
)
```



```{r}
library(nlme)

compute_bm_sem_rich_var <- function(.data, rich_var = "log_rich_tot_std", random_effect = "~ 1 | basin", get_sem = FALSE) {

  formula_list <- list(
    rich = paste0(rich_var, " ~ log_RC1 + log_RC2"),
    ct = paste0("ct ~ log_RC1 + log_RC2 + ", rich_var),
    t_lvl = paste0("t_lvl ~ log_RC1 + log_RC2 + ", rich_var),
    bm = paste0("log_bm_std ~ ", rich_var," + ct + t_lvl + log_RC1 + log_RC2")
  )
  model_list <- map(formula_list, function(x)  {
    temp_model <- nlme::lme(as.formula(x), random = ~ 1 | basin, data = .data)
    temp_model$call$fixed <- as.formula(x)
    return(temp_model)
  }
    )

  corsem <- piecewiseSEM::as.psem(model_list)

  if (get_sem) {
    return(corsem)
  }
  output <- summary(corsem, .progressBar = F)

  return(output)
}
compute_stab_sem_rich_var <- function(.data, rich_var = "log_rich_tot_std", random_effect = "~ 1 | basin", get_sem = FALSE) {

  formula_list <- list(
    rich = paste0(rich_var, " ~ log_RC1 + log_RC2"),
    ct = paste0("ct ~ log_RC1 + log_RC2 + ", rich_var),
    t_lvl = paste0("t_lvl ~ log_RC1 + log_RC2 + ", rich_var),
    sync = paste0("log_sync ~ ", rich_var, " + ct + t_lvl + log_RC1 + log_RC2"),
    cvsp = paste0("log_cv_sp ~ ", rich_var," + ct + t_lvl + log_RC1 + log_RC2") 
    )

  model_list <- map(formula_list, function(x)  {
    temp_model <- nlme::lme(as.formula(x), random = ~ 1 | basin, data = .data)
    temp_model$call$fixed <- as.formula(x)
    return(temp_model)
  }
    )

  ## Add linear model
  model_list <- c(
    model_list,
    stab = list(lm(log_stab_std ~ log_cv_sp + log_sync, data = .data))
  )

  corsem <- piecewiseSEM::as.psem(model_list)

  if (get_sem) {
    return(corsem)
  }
  output <- summary(corsem, .progressBar = F)

  return(output)
}
sem_data %<>%
  mutate(log_rich_std = log(rich_std_med))
```

```{r}
rich <- names(sem_data)[str_detect(names(sem_data), "log_rich")]
```


```{r}
bm_sens_rich <- map(rich, 
  ~compute_bm_sem_rich_var(
    .data = sem_data,
    rich_var = .x, random_effect = "~ 1 | basin",
    get_sem = FALSE)
)
names(bm_sens_rich) <- rich

sem_bm_results_rich <- map(bm_sens_rich,
  ~.x$coefficients[-ncol(.x$coefficients)]) %>%
  enframe() %>%
  rename(dataset = name) %>%
  unnest(value) %>%
  mutate_at(c("Response", "Predictor"), ~ifelse(str_detect(., "rich"), "richness", .))

colnames(sem_bm_results_rich) <- str_to_lower(colnames(sem_bm_results_rich))

cols_rich <- c(
  "log_rich" = "red",
  "log_rich_std" = "blue",
  "log_rich_tot_std" = "darkgreen",
  "log_rich_tot" = "orange"
)
label_rich <- c(
  "log_rich" = "Log median richness",
  "log_rich_std" = "Log median of standardized richness",
  "log_rich_tot_std" = "Log standardized total richness",
  "log_rich_tot" = "Log total richness"
)

p_sens_bm_rich <- plot_sensivity_analysis(
  .data = sem_bm_results_rich,
  inverse_label_order = TRUE, scale_color = FALSE,
  y_lim = c(-1.5, .75)
  ) +
geom_point(aes(colour = "pink", size = 4)) +
scale_color_manual(
  values =  cols_rich,
  labels = label_rich,
  breaks = names(label_rich)) +
  guides(color = guide_legend(direction = "horizontal", nrow = 1)) +
  theme(legend.position = "bottom", plot.margin = unit(c(0, 0, 0, 25), units = "mm"))
```

```{r}
stab_sens_rich <- map(rich, 
  ~compute_stab_sem_rich_var(
    .data = sem_data,
    rich_var = .x, random_effect = "~ 1 | basin",
    get_sem = FALSE)
)
names(stab_sens_rich) <- rich

sem_stab_results_rich <- map(stab_sens_rich,
  ~.x$coefficients[-ncol(.x$coefficients)]) %>%
  enframe() %>%
  rename(dataset = name) %>%
  unnest(value) %>%
  mutate_at(c("Response", "Predictor"), ~ifelse(str_detect(., "rich"), "richness", .))

colnames(sem_stab_results_rich) <- str_to_lower(colnames(sem_stab_results_rich)) 

cols_rich <- c(
  "log_rich" = "red",
  "log_rich_std" = "blue",
  "log_rich_tot_std" = "darkgreen",
  "log_rich_tot" = "orange"
)
label_rich <- c(
  "log_rich" = "Log median richness",
  "log_rich_std" = "Log median of species richness density",
  "log_rich_tot_std" = "Log species richness density",
  "log_rich_tot" = "Log total richness"
)

p_sens_stab_rich <- plot_sensivity_analysis(
  .data = sem_stab_results_rich,
  inverse_label_order = TRUE,
  scale_color = FALSE, y_lim = c(-1.4, .75)) +
scale_color_manual(
  values =  cols_rich,
  labels = label_rich,
  breaks = names(label_rich)) +
  guides(color = guide_legend(direction = "horizontal", nrow = 1)) +
  theme(legend.position = "bottom", plot.margin = unit(c(0, 0, 0, 25), units = "mm"))
```

```{r rich-sens, fig.dim = c(10, 14), fig.cap="Sensivity of the standardized estimates to species richeness specification for the two structural equation model."}
legend_b <- get_legend(p_sens_stab_rich)
p <- plot_grid(
  p_sens_bm_rich %<>% + theme(legend.position = "none", plot.margin = unit(c(0,0,0,27), units = "mm")),
  p_sens_stab_rich %<>% + theme(legend.position = "none", plot.margin = unit(c(0,0,0,27), units = "mm")),
  legend_b, nrow = 3,
  rel_heights = c(1, 1, .1),
  labels = c("Total biomass", "Biomass stability")
)
p
```

