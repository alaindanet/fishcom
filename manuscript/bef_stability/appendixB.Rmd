---
title: Appendix B
subtitle: Species richness and food-web structure jointly drive community biomass and its temporal stability in fish assemblages 
author: Alain Danet, Maud Mouchet, Willem Bonnaffé, Elisa Thébault and Colin Fontaine
date: \today 
output:
  bookdown::pdf_document2:
    fig_caption: true 
    keep_tex: true
    toc: true
fontsize: 12pt
header-includes:
   - \usepackage{natbib}
   - \newcommand{\beginsupplement}{\setcounter{table}{2}  \renewcommand{\thetable}{S\arabic{table}} \setcounter{figure}{0} \renewcommand{\thefigure}{S\arabic{figure}}} 
   - \usepackage{float}
   - \usepackage[table]{xcolor}
   - \usepackage{multirow}
   - \usepackage{booktabs}
   - \usepackage{makecell}
   - \usepackage{setspace}
   - \doublespacing
   - \usepackage{lineno}
   - \linenumbers
geometry: margin=2cm
bibliography: references.bib
number_sections: true
nocite: |
    @post_ecosystem_2000| @doi_resource_2009| @mchugh_dual_2010|
    @ogorman_unexpected_2017| @gauzens_biodiversity_2020| @dunne_network_2006|
    @mchugh_dual_2010| @doi_resource_2009| @allan_stream_2009|
    @petchey_predicting_2010| @winemiller_must_1989 | @galiana_spatial_2018 | @ogorman_simple_2019| @oksanen_exploitation_1981| @thebault_trophic_2005| @mccann_more_2009| @jiang_different_2009| @fussmann_ecological_2014| kratina_warming_2012
csl: ecology-letters.csl
---

```{r, echo = FALSE, message = FALSE, collapse = FALSE}

mypath <- rprojroot::find_package_root_file
data_common <- mypath("data")
dest_dir <- mypath("data", "species")

load(file = mypath("manuscript", "bef_stability", "result", "workspace.rda"))

knitr::opts_chunk$set(
  cache = TRUE,
  collapse = TRUE,
  comment = "#>",
  #fig.dim = c(7, 7),
  fig.fullwidth = TRUE,
  fig.show = "hold",
  echo = FALSE,
  message = FALSE,
  warning = FALSE,
  results = TRUE
)

library(tidyverse)
library(magrittr)
library(ggeffects)
library(cowplot)
library(kableExtra)
library(sf)
library(nlme)
source(mypath("R", "misc.R"))
source(mypath("R", "plot_methods.R"))
source(mypath("R", "community_analysis.R"))
source(mypath("R", "community_methods.R"))
source(mypath("R", "statistical_analysis.R"))
source(mypath("R", "total_sem_effect.R"))
source(mypath("R", "press_methods.R"))
source(mypath("R", "geo_methods.R"))
source(mypath("R", "synchrony.R"))
source(mypath("R", "cleaning_methods.R"))

theme_set(theme_alain())
```

\beginsupplement

```{r, echo = FALSE}
package <- c("openSTARS", "SSN", "nlme", "piecewiseSEM")
#purrr::map(package, ~ toBibtex(citation(.x)))

#toBibtex(citation())

#print(cm, bibtex = TRUE)
# Load manuscript results
```

# Data collection and preparation 

## Fishing

### Protocol

The monitoring of the fish communities occurs in streams varying in size, shape
and depth. Stream characteristics constrain the type of protocol
applied. Small streams (depth < 0.7m across the entire width) are sampled with
the "complete" protocol. Anodes are distributed across the width of the river
then one to three electric fidhing events are performed. We selected only the
data from the first event to homogenize the sampling effort. In deeper and wider
streams (depth >= 0.7m), the sampling is
partial over the bank and the channel and it is performed by boat and by foot
(along the bank). We selected only the sampling done over the bank because the
channel was not systematically sampled. Two types of partial protocols takes
place: "partial over bank" and "partial by points", which are respectively
continuous and discrete samplings. We considered both types of partial protocols
in our analysis. In the "partial by point" protocol, the channel was sometimes
sampled as well, so we selected only the "partial by point" sampling in which
all the sampling points were done over the bank to homogenize the sampling. Some
sampled stations were located in streams with intermediate characteristics where
both "complete" and "partial" protocols were alternatively used depending on the
state of the stream at the time of sampling. For these sites, we only kept the
samples that had been carried out with the most frequently used protocol.

Heterogeneity in the sampling date may introduce variability due to different
climatic or environmental conditions but also to the life cycle of the species.
For instance, early surveys may precede the egg hatching and youngs-of-the-year.
In order to reduce heterogeneity in the sampling date, only one sampling per
year was retained if there were more in a given year, the one that had the most
species and then the most individuals. Finally, most of the fish sampling
occurred in September (Median: mid-August). There was low heterogeneity of the
sampling month within stations, with the median sampling month being mid-August
where the median standard deviation of the sampling month was  month, i.e. three
weeks. To further reduce sampling heterogeneity, we only kept the sampling in
which the length of stream sampled along the stream was inside the median length
sampled more or less 30%.

### Batches definition and body size measurement 

Once the fishes have been caught, they are divided into different batches (Fig.
\@ref(fig:p-body-size)). Each batch contains only one species but individuals of
one species can be distributed in several batches. The body size of the fishes
is measured differently for each type of batch.  There are four types of
batches: N, I, S/L and G. The batches N and I contain the largest individuals.
In the N and I batches, the body size of all the individuals is recorded. The
batches S/L contain fishes of intermediate sizes. Inside each S/L batch, the
operator tries to make batches as homogeneous as possible in terms of body size.
Then, the body size of a subsample of at least 20 individuals is recorded. The G
batches contain individuals of small body size. In G batches, the body size of
the shortest and the largest individuals are recorded.

## Body size inference

```{r}
myload(fish_length, lot_id_opcod, dir = mypath("data-raw", "fishing_op_build"))

fish_length %<>%
  left_join(lot_id_opcod) %>%
  rename(length = fish) %>%
  select(opcod, species, length)

length_sem_analysis <- fish_length %>% 
  filter(opcod %in% op_analysis_bbb$opcod)
rm(fish_length, lot_id_opcod)
nrow_fish_length <- nrow(length_sem_analysis)
na_length <- sum(is.na(length_sem_analysis$length))
```

Body size inference was guided by the recommendations of
the OFB agency, which has defined the sampling protocols, supervised the data
collection and performed analyses on the dataset for multiple purpose including stream
management. The database was obtained from the OFB agency. 

```{r, cache = FALSE}
body_size_caption <- paste0(
  "Body size inference of the fishes. ",
  "(1) Sampled fishes were attributed to batch type according to their size and
  the number of individuals. A batch contains one species only. (2) In the batch
  type N and I, the body size of all the individuals was recorded. In the
  batches, S/L, the body size of a subsample of the individuals was recorded.
  Finally, only the body size of the smallest and of the largest individual were
  recorded in the G batches. ",
  "Then, (3) we inferred the body size distribution in the S/L and G batches by
  assuming a normal distribution. The mean and the standard
  deviation were estimated with the measured subsample."
) 
```

```{r p-body-size, cache = FALSE, fig.cap=body_size_caption}
knitr::include_graphics(mypath("manuscript", "bef_stability", "figs", "length_inference.pdf"))
```

We inferred the body size of all the unmeasured individuals using the batch
records. There was no need for inference for the N and I batches since the body
size of all individuals was recorded (Fig. \@ref(fig:p-body-size)). The body
size ($l$) of the fishes in the S/L and G was inferred under the assumption that
body size distribution follows a normal law ($l \sim N(\mu, \sigma)$).  For an S/L
batch, the mean $\mu$ and the standard deviation $\sigma$ were simply the
average and the standard deviation of the body sizes of the subsample recorded.
For a G batch, the average was approximated by $\hat{\mu} = (l_{min} +
l_{max}) / 2$ and the standard deviation by $\hat{\sigma} = (l_{min} + l_{max})
/ 4$. With the estimations of the mean and the standard deviation, the number
of individuals in a batch and the assumption of normal distribution, we
simulated the body size distribution in S/L and G batches. To avoid simulation
of unrealistic body size, we used a truncated normal distribution bounded at
[0.05; .95] for the density of probability of the S/L batches, and bounded at
[$l_{min}$; $l_{max}$] for the G batches. Body size distributions were generated
using the R function `truncdist::rtrunc`.

Batches that did not meet conditions regarding the number of individuals were
excluded.  We excluded batches for which the total number of individuals was not
recorded. We also excluded G batches for which $l_{min} \geq l_{max}$ or if at
least one of the measurement was missing. Additionally, a given G batch was
excluded when the number of individuals felt below 5, as G batches normally
contained more individuals. We excluded S/L batches for which the number of
measured individuals was inferior to 10, because it indicates a potential
problem in the batch. Finally, in the dataset used in the analysis, `r
na_length` individuals had missing length over `r nrow_fish_length` individuals,
and body size was inferred for these individuals.


## Community data

```{r}
source(mypath("R", "cleaning_methods.R"))
removed_ind <- filter(length_sem_analysis, species %in% sp_to_remove())
removed_sp <- unique(removed_ind$species)
```

The rare fish species, species from lake, crayfish species, and migratory
species were excluded. In total, we removed `r nrow(removed_ind)` over 
`r nrow(length_sem_analysis)` individuals and `r length(removed_sp)` species.

Some species were identified to subspecies, based on their morphotype, but they
belong to the same species based on fecundation criteria. We merged those
subspecies into one species. We merged 
`r length(unique(names(sp_to_replace())))` morphotypes into
`r length(unique(sp_to_replace()))` species.

### Metaweb

#### Ontogenic diet

Diet information was obtained from fishbase.org and literature (Appendix A,
Table S2). The diet information contained from two to three life stages by
species, the life stages being defined by the body size of the fishes. Over the
57 fish species, only 7 had a piscivorous life stage and only three had a strict
piscivorous life stage. Fish species were then largely omnivorous.


```{r food, eval = FALSE}
onto_shift_cap <- paste0(
  "Ontogenic diet shift for each fish species.", 
  "Species had between two and three life stages, bounded by body size (in mm).
  A life stage of a given determine its diet. The fourth column to the last one
  correspond to this respective resource: light, detritus, biofilm,
  phytobenthos, macrophages, phytoplankton, zooplankton,  zoobenthos and
  fishes."
)
table_onto_diet <- fish_diet_shift %>%
  rename(`Life stage` = stage) %>%
  mutate(
    min = paste0("[", size_min),
    max = paste0(size_max, "]")
  ) %>%
  unite("Size interval", min:max, sep = ";") %>%
  select(species, `Life stage`, `Size interval`, light:ref_ods)

kable(table_onto_diet,
  format = "latex",
  booktabs = T,
  label = paste0("onto-diet"),
  caption = onto_shift_cap
  ) %>%
kable_styling(latex_options =c("striped", "scale_down"))
```

```{=latex}
%\includepdf[pages={2-7}]{figs/supplementary_ref_willem.pdf}
```


#### Definition of trophic interactions

```{r, cache = FALSE} 

trophic_building_caption <- paste0( "Define trophic species and trophic
  interactions. (1) Each
  species is divided into 9 body size classes. We gathered data about
  the food diet of each fish species and how food diet varies according to
  ontogeny. (2) The life stage of a trophic species is determined by the
  median of the body size class, hereafter midpoint. A trophic link is set between the trophic
  species and the resources associated to this life stage. (3) For piscivorous
  trophic species, the trophic links among fishes are defined according to
  the predator/prey body size ratio. The predation window of a trophic
  species ranges from 3% to 45% of its midpoint. A trophic
  link is set between the predator trophic species and every trophic species whose
  midpoint of body size class range was included in the predation window.") 

```

```{r p-net-inf, cache = FALSE, fig.cap=trophic_building_caption}
knitr::include_graphics(mypath("manuscript", "bef_stability", "figs", "network_inference.pdf"))
```

```{r}
myload(metaweb_analysis, dir = mypath("data"))
species_in_metaweb <- metaweb_analysis$species

length_sem_analysis %<>%
  filter(!species %in% sp_to_remove()) %>%
  mutate(
    species = str_replace_all(species, sp_to_replace())
  )

removed_ind_metaweb <- length_sem_analysis %>%
  filter(!species %in% species_in_metaweb)
removed_sp_metaweb <- unique(removed_ind_metaweb$species)
```

```{r, cache = FALSE}
metaweb_caption <- paste0(
  "The metaweb describing the trophic interactions between all the 412 trophic species. Each trophic species is
  represented by a node and each color represents a species (S = 45). The 7 
  resource nodes are drawn in grey. The species names corresponding to the
  three digit codes are found in Table S1."
)
```

```{r metaweb, cache = FALSE, fig.cap=metaweb_caption}
knitr::include_graphics(mypath("manuscript", "bef_stability", "figs", "metaweb2.png"))
```

The metaweb describes the potential trophic interactions between the
($`r ncol(metaweb_analysis$metaweb) - length(metaweb_analysis$resource)`$) trophic species.
The metaweb also included seven resource nodes which were present in the diet of the trophic
species namely detritus, biofilm, phytoplankton, zooplankton, macrophages,
phytobenthos and zoobenthos (Fig. \@ref(fig:metaweb)).

Trophic interactions between the nodes of the metaweb were determined according to
the diet and the body size of the trophic species. We removed 
`r length(removed_sp_metaweb)` species because data about their diet was missing. It
represented  `r nrow(removed_ind_metaweb)` individuals over
`r nrow(length_sem_analysis)` individuals.

The life stage to which a trophic species belongs was determined by the median
of the body size range of the trophic species, each life stage being delimited
by a body size range. In return, this trophic species has trophic interactions
with the resource nodes of its life stage. The trophic interactions between a
predator and a prey were determined by the predator-prey body size ratio
[@brose_predator_2019; @poisot_structure_2016; @schneider_body_2012]. For a
given trophic species, we first determined if its body size range overlapped
with a piscivorous life stage (Fig. \@ref(fig:p-net-inf)). If the trophic
species was piscivorous, we determined its prey size range from 3% to 45% of the
median of its size range. A trophic interaction was set for each trophic species
whose corresponding size class median felt into the prey range of the predator
trophic species (Fig. \@ref(fig:p-net-inf)). To sum up, the metaweb contains
feeding interactions (1) between trophic species, (2) between trophic species
and resource nodes and (3) between resource nodes.

#### Local food-webs 

The local food-webs (i.e. one network by
sampling) were obtained by determining the trophic species of each fish
individual in the community. According to the trophic species present in a given
community, we set the trophic interactions between them as defined in the metaweb. 
All the resource nodes were assumed to be present in each local network.
Thus, the structure of the local food-webs varied according to the presence of
the trophic species.

## Environmental variables

The procedures to obtain altitude, slope, width and depth of the streams are fully
explained in main text. Because those measurements were collected during the
fishing protocol, they were easier to manage in the analyses. Then, we detail
in the following sections how water temperature, water flow and Biological
Oxygen Demand (BOD) variables were obtained. In the following section, we will
present how we averaged each variable to match the annual fish monitoring
events. We also detailed how we interpolated these variables to match the
spatial location of the fish samplings.

### Preparation

Water temperature, water flow and BOD variables were obtained from the [naiades
database](http://www.naiades.eaufrance.fr/) and were respectively collected at
an hourly, daily and monthly frequency. Water temperature and flow are recorded
by automated sensors while BOD is collected manually because its measurement
requires laboratory analysis. BOD data collection is coordinated by the Agence
de l'eau (i.e. French national water agency).  

```{r, cache = FALSE}
pressure_cap <- paste0(
  "Map of the environmental variables obtained for the 99 sites used in the
  analysis. The inner borders delimit the hydrographic basins. Slope is expressed in degree, altitude in meter, distance from
  source in kilometer, Strahler order has no units, average stream width and
  depth are expressed in meter, Biological Oxygen Demand (BOD) is expressed in
  mg of dissolved oxygen, water flow is expressed in cubic meter per second and
  water temperature is expressed in Celsius degree.")
```


```{r, cache = FALSE, fig.height = 20/2.54, fig.cap = pressure_cap}
pca_pressure <- habitat_press
myload(fourier, dir = mypath("data-raw", "polluants"))
myload(flow_temp_metrics, station_analysis, the_8_hydrologic_basin, dir = mypath("data"))

sf_pressure <- station_analysis %>% 
  filter(id %in% op_analysis_bbb$station) %>%
  select(id) %>%
  left_join(rename(pca_pressure, id = station)) %>%
  na.omit()

p <- ggplot() +
  geom_sf(data = the_8_hydrologic_basin)

var_to_plot <- colnames(pca_rotated$normal$tab)

var_replacement <- c(
  "slope" = "Slope",
  "alt" = "Altitude",
  "d_source" = "Distance from source",
  "strahler" = "Strahler order",
  "width_river_mean" = "Average stream width",
  "avg_depth_station_mean" = "Average stream depth",
  "width_river_cv" = "CV of stream width",
  "avg_depth_station_cv" = "CV of stream depth",
  "DBO_med" = "Average BOD",
  "flow_med" = "Average flow",
  "temperature_med" = "Average temperature",
  "DBO_cv" = "CV of BOD",
  "flow_cv" = "CV of flow",
  "temperature_cv" = "CV of temperature"
)

map_pressure <- map(var_to_plot,
~p +
  geom_sf(data = sf_pressure, aes_string(color = .x), size = .5) +
  viridis::scale_color_viridis() +
  labs(title = str_replace_all(.x, var_replacement)) +
  theme(
    legend.title = element_blank(),
    text = element_text(size = 8),
    axis.text = element_blank(),
    axis.ticks = element_blank()
  ) +
 guides(color = guide_colourbar(barwidth = 0.5, barheight = 4))
)

plot_grid(plotlist = map_pressure, ncol = 3)
```

To smooth out the seasonal patterns of temperature variation across year and
keep the general trends, we applied a moving window averaging to each time
series. The moving window was applied on daily average temperature. Then we took
the annual mean of each year and each variable (i.e. one value by year and by
station).
 
We used stream spatial network methods to interpolate water temperature, water
flow and BOD. Indeed, stream characteristics make interpolation more
complicated than in terrestrial areas. Interpolations in terrestrial areas are
often based on euclidean distance, which is not possible for streams as two
streams can be close but disconnected. For those reason, we used stream spatial
network methods to interpolate water temperature, water flow and BOD.

We reconstructed the stream network and the connection between stations with the
`openSTARS` R package [@kattwinkel_preparing_2020]. The reconstruction was done with a raster of digital
elevation model at a resolution of 250 meters [(link to the raster)](https://wxs.ign.fr/jvam1hsjm11u8voorw81v2xb/telechargement/prepackage/BDALTI-75M_PACK_FXX_2018-01-24%24BDALTIV2_2-0_75M_ASC_LAMB93-IGN69_FRANCE_2018-01-15/file/BDALTIV2_2-0_75M_ASC_LAMB93-IGN69_FRANCE_2018-01-15.7z)
and a theoretical hydrologic network, which is more convenient to use than the observed one [@pella_reseau_2012].

The interpolations were carried out by hydrographic basin due to convergence
issues when the interpolation was carried out at the scale of the whole
France. We had to find a trade-off between the number of data (to keep 
high enough to perform the interpolation) and the level of dataset splitting. We then
merged some hydrographic basins to end up with four regions of interpolation:
West, East, South and North.

We modelled each variable, i.e. water temperature, water flow and BOD, as dependant only on the covariation between
sites taking in account the stream network. The autocovariance between
sites was modelled with the linear-sill and mariah functions for taildown and tailup
autocovariance, according to their predictive performance. The interpolations
were done with the `SSN` R package [@isaak_applications_2014; @hoef_ssn:_2014].


### Performance and post check

```{r, cache = FALSE}
cv_bias_caption <- paste0(
  "Bias of the interpolation from Leave-One-Out Cross Validation (LOOCV). "
)
```

```{r, eval = TRUE}
myload(cv_press_interp_mv_avg,
  dir = mypath("data-raw", "polluants"))
myload(cv_temp_press_interp_mv_avg,
  dir = mypath("data-raw", "naiades_temperatures"))
myload(cv_flow_press_interp_mv_avg,
  dir = mypath("data-raw", "flow"))
dbo_cv <- cv_press_interp_mv_avg %>%
  filter(parameter == "dbo5")

cv_dbo_temp_flow <- map2_dfr(
  list(dbo = dbo_cv, temp = cv_temp_press_interp_mv_avg, flow = cv_flow_press_interp_mv_avg),
  c("BOD", "Temperature", "Flow"),
  function(x, y) {
    x %>%
      select(basin, year, bias, std.bias, RMSPE, std.MSPE) %>%
      group_by(basin) %>%
      summarise_if(is.numeric, list(avg = ~mean(., na.rm = TRUE), sd = ~sd(., na.rm = TRUE))) %>%
      mutate(Variable = y) %>%
      select(Variable, basin, everything()) %>%
      ungroup
  })

```
```{r, cache = FALSE}

cv_dbo_temp_flow %>%
  mutate_if(is.double, ~signif(., 2)) %>%
  kable(
    align = "c",
    format = "latex",
    booktabs = T,
    caption = paste0("Results of the cross-validation for the interpolation of
      BOD, temperature and flow. The averages over 4 interpolations are shown. The
      cross-validation were performed with the SSN R package. bias: average
      predicted error, std.biais: bias standardized, RMSPE: Root Mean-Squared
      Prediction Error, std.MSPE: standardized Mean-Squared Prediction Error.") ) %>%
    collapse_rows(columns = c(1, 2), valign = "top") %>%
    kable_styling(latex_options =c("striped", "scale_down"))
```



The performance of the interpolations was evaluated with leave one out
cross-validation (already implemented in the SSN package), i.e. the value of the
interpolated variable of each station was predicted after removing it from the
dataset.

When predicted values were below the minimum value or above the maximum value
recorded in the dataset for flow, temperature and BOD, we replaced the
predicted value by respectively the minimum and the maximum value found in the
dataset. We ran the interpolation four times, and we kept the predicted value
which had the smaller standard deviation.


# Data analysis

## Temporal series classification

The CV of biomass over time can cover multiple temporal dynamics, including
increases, stable, decreases and a mix of them. Theoretically, however, the CV
computed to quantify stability is often represented with the assumption that the
overall dynamic of the biomass varies around an equilibrium
[@kefi_advancing_2019]. In order to approach the condition of equilibrium, we
kept only the stations that show no clear temporal trends. To characterise the
biomass temporal dynamics according to their trajectories, we used the symbolic
aggregated approximation method (SAX), which is commonly used in time series
analysis and implemented in the `jmotif` R package [@senin_grammarviz_2018].
This method classifies time series rather than quantifies trends. Therefore, it
is enough generic to encompass a diversity of temporal trajectories. The
classification necessitates three steps. The time series are first normalized.
Then, we reduced the dimensionality of the time series by a Piecewise
Aggregation Approximation (PAA) method. Each time series is divided into $N$
frames of equal size that allows to reduce the dimensionality of the time
series. For each frame, we simply kept the mean value of the time series.  The
final stage is to qualify each frame into string. Because values of normalized
time series typically follows a normal distribution ($N(0,1)$), a breakpoint can
be computed by dividing the area under the normal distribution in equal parts.
The algorithm attributes an alphabetic letter to each part from the lowest to
the highest ($a$, $b$, $c$, ...). We set three breakpoints, so $a$, $b$ and $c$.
Finally, the trajectory of each time series is classified as a combination of
$a$, $b$, $c$ letters. $abc$ and $cba$ time series represent respectively
monotonic increasing and decreasing trajectories. For data analysis, we kept
only the $bbb$ which represent time series that showed no temporal tendencies,
with respect to our methodology.


## PCA over environmental variables

```{r eig-plot}
rotated_eigen_values <- 
  tibble(
    name = paste0("RC", seq(1,14)),
    type = c(rep("Kept", 2), rep("No kept", 14 - 2)),
    value = pca_rotated$rotated$values
  )
eigen_rotated_plot <-
  ggplot(rotated_eigen_values,
    aes(x = reorder(name, -value) , y = value)) +
  geom_col(aes(fill = type)) +
  scale_fill_discrete(name = "Status") +
  labs(x = "Rotated component", y = "Eigenvalues") +
  theme(legend.position = "none",
    axis.text.x = element_blank(),
    axis.ticks.x = element_blank())
```

```{r contrib-pca, cache = FALSE}
#https://stats.stackexchange.com/a/143949
caption_contrib_pca <- paste0(
  "Loadings of variable to rotated components of the PCA.
  Loadings are the coordinates of the variables in the space of the PCA
  components.
  "
)

loadings_pca <- matrix(
  as.matrix(round(pca_rotated$rotated$Structure, 2)),
  nrow = 14,
  dimnames = dimnames(pca_rotated$rotated$Structure)
  ) %>%
  as_tibble %>%
  mutate(
    Variable = str_replace_all(
      dimnames(pca_rotated$rotated$Structure)[[1]],
      get_pca_var_name_replacement())
  ) %>%
  select(Variable, RC1, RC2)
kable(
  x = loadings_pca,
  format = "latex",
  booktabs = T,
  label = "contrib-pca",
  caption = caption_contrib_pca
  ) %>%
kable_styling(latex_options = c("striped"))
```

```{r, eval=FALSE, cache = FALSE}
corr_pca_caption <- paste0(
  "Spearman correlation between environmental variables used in the PCA.
  The variables have been scaled before to compute the correlation."
) 

pca_var_correlation <- pca_pressure %>%
  select(-station) %>%
  #mutate_all(scale) %>%
  as.matrix() %>%
  cor(., method = "spearman")

pca_var_correlation %<>% round(., 2)
dimnames(pca_var_correlation) %<>%
  map(., ~str_replace_all(.x, get_pca_var_name_replacement()))

kable(
  x = pca_var_correlation,
  format = "latex",
  booktabs = T,
  label = "corr-pca",
  caption = corr_pca_caption
  ) %>%
kable_styling(latex_options = c("striped", "scale_down"))
```

```{r, cache = FALSE}
prop_var_expl_pca <- pca_rotated$rotated$Vaccounted["Proportion Var", ] %>%
  map_dbl(., ~round(.x * 100))

tot_var_expl_pca <- round(sum(pca_rotated$rotated$Vaccounted["Proportion Var", ]) * 100) 

pca_caption <- paste0(
  "Eigenvalues distribution, we kept the first two axis for the data analysis." 
  )
```

```{r pca-rotated, cache = FALSE, fig.cap = pca_caption}
p1 <- my_pca_plot(xaxis = "RC1", yaxis = "RC2", ctb_thld = .4)
#p2 <- my_pca_plot(xaxis = "RC3", yaxis = "RC4", ctb_thld = .4)
#p3 <- my_pca_plot(xaxis = "RC4", yaxis = "RC5", ctb_thld = .4)

pca_plot <- plot_grid(eigen_rotated_plot, nrow = 1)
save_plot(
  filename = mypath("manuscript", "bef_stability", "figs", "pca_plot.pdf"),
  pca_plot,
  nrow = 1, ncol = 2,
  base_height = 6/2.54, base_asp = 1.6, base_width = NULL 
  )
pca_plot
```


```{r}
print_prop_var_pca <- prop_var_expl_pca[order(names(prop_var_expl_pca))]
```

```{r }
rc2 <- tibble(
  station = pca_pressure$station,
  alt = pca_pressure$alt,
  temperature_med = pca_pressure$temperature_med,
  value = pca_rotated$rotated$scores[,"RC2"]
)

rc2_sf <- station_analysis %>%
  select(station = id) %>%
  filter(station %in% rc2$station) %>%
  left_join(rc2, by = "station")

caption_rc2_map <- paste0(
  "Map of the station values for the second axis of the rotated PCA."
)
```

```{r rc2-map, eval = FALSE, fig.cap = caption_rc2_map}
p +
  geom_sf(data = rc2_sf, aes(color = log(value + abs(min(value)) + 1 ))) +
  viridis::scale_color_viridis() +
  labs(title = "RC2 (Log)") +
  theme(legend.title = element_blank())
```

```{r pca-two-axis, eval = FALSE}
two_axis <- compute_rotated_pca(.data = pca_pressure, naxis = 2)
two_axis$rotated$Vaccounted

cor(two_axis$rotated$score[,c("RC1", "RC2")],
  pca_rotated$rotated$score[,c("RC1", "RC2")])
```

```{=latex}
\pagebreak
```

# Statistical analysis 


```{r, cache = FALSE, fig.pos = "!H", out.extra = ""}
sem_variable_table <- tibble(
  Variable = c(paste0("PCA axis", seq(1, 2)), "Species richness", "Connectance", "Average trophic level", "Synchrony", "CVsp", "Total biomass"),
  Unit = c(rep("unitless", 2), "number by square meter", rep("unitless", 4), "gram by square meter"
    ),
  Transformation = c("Log base 10", "Log base 10 and inversion", "Log base 10", rep("No", 2), rep("Log base 10", 3)),
  Description = c("linked to stream size",
    "linked to average temperature and BOD",
    "Total species richness over the temporal series",
    "Median of annual link density", "Median of annual average trophic level",
    "Temporal synchrony in the dynamics of population biomass", "Average
    variability of population biomass", "Median of annual total biomass")) %>%
kable(
  format = "latex",
  booktabs = T,
  caption = "The description of the variables used in the structural equation models."
  ) %>%
kable_styling(latex_options = c("striped", "scale_down"))
sem_variable_table
```

\begin{table}
\caption{\label{tab:hyp-sem} Presentation of the links 
of the Structural Equation Models associated with the references supporting the links.}
\begin{center}
\begin{tabular}{ m{7cm}| m{1cm}| m{6cm}}
    \hline
    Link & sign & reference\\
    \hline
    PCA1 Avg stream size $\to$ Species richness & (+) & Galiana et al. (2018) \\
    \hline
    PCA2 Avg temperature $\to$ Species richness & (+/-) & Woods et al. (2020); Gauzens et al. (2020) \\
    \hline
    PCA1 Avg stream size $\to$ Connectance & (-) & Galiana et al. (2018) \\
    \hline
    PCA2 Avg temperature $\to$ Connectance & (+/-) & O’Gorman et al. (2019);
    Oksanen et al. (1981)\\
    \hline
    Species richness $\to$ Connectance & (-) & Winemiller (1989); Dunne (2006) \\
    \hline
    PCA1 Avg stream size $\to$ Avg trophic level & (+) & Post et al. (2000); Doi et al. (2009); McHugh et al. (2010) \\
    \hline
    PCA2 Avg temperature $\to$ Avg trophic level & (+/-) & O’Gorman et al. (2017)\\
    \hline
    Species richness $\to$ Avg trophic level & (+) & Schneider et al. (2016)\\
    \hline
    Species richness $\to$ Synchrony & (-) & Thébault and Loreau (2005); Loreau and de Mazancourt (2008); Thibaut and Connolly (2013) \\
    \hline
    Connectance $\to$ Synchrony & (+) & Thébault and Loreau (2005)\\
    \hline
    Avg trophic level $\to$ Synchrony & (+) & Raimondo et al. (2004); McCann and Rooney (2009) \\
    \hline
    PCA1 Avg stream size $\to$ Synchrony & (-) & Wang et al. (2019)\\
    \hline
    PCA2 Avg temperature $\to$ Synchrony & (?) & \\
    \hline
    Species richness $\to$ CVsp & (+) & Jiang et al. (2009)\\
    \hline
    Connectance $\to$ CVsp & (+) & Thébault and Loreau (2005)\\
    \hline
    Avg trophic level $\to$ CVsp & (-) & McCann and Rooney (2009); Shanafelt and Loreau (2018)\\
    \hline
    PCA1 Avg stream size $\to$ CVsp & (?) & \\
    \hline
    PCA2 Avg temperature $\to$ CVsp & (+) & Kratina et al. (2012); Fussmann et al. (2014)\\
    \hline
    CVsp $\to$ Biomass stability & (-) & Thibaut and Connolly (2013)\\
    \hline
    Synchrony $\to$ Biomass stability & (-) & Thibaut and Connolly (2013)\\
    \hline
    Species richness $\to$ Total biomass & (+) & Schneider et al. (2016)\\
    \hline
    Connectance $\to$ Total biomass & (+/-) & Thébault and Loreau (2003); Poisot
    et al. (2013)\\
    \hline
    Avg trophic level $\to$ Total biomass & (+) & Wang and Brose (2018)\\
    \hline
    PCA1 Avg stream size $\to$ Total biomass & (+) & Post et al. (2000); Allan and Ibanez Castillo (2009); Doi et al. (2009)\\
    \hline
    PCA2 Avg temperature $\to$ Total biomass & (+/-) & Kratina et al. (2012);
    Tabi et al. (2019)\\
    \hline
    \end{tabular}
\end{center}
\end{table}


---
#### SEM hypothesis
#
#We linked environmental variables both to community structure and stability
#components. Rooted in assembly theory, environment filters species that can
#establish in a community and thus affect community structure. (+ add specific
#hypothesis about physical and climate). (1) We hypothesized that enrichment
#(characterized by DBO) and mean annual temperature will increase species turnover
#[@friedpetersen_drivers_2020]. (2) We hypothesized environmental forcing can also
#decrease biomass stability directly without going by community structure. First,
#instability of habitat and environmental factors may in turn drive biomass
#instability [@hansen_climate_2013]. Secondly, average environmental conditions
#such as enrichment can increase directly CV by increasing species biomass
#fluctuations [@tabi_warming_2019]. Increasing temperature was also hypothesized
#to decrease stability through starvation resulting from high metabolic activity
#[@tabi_warming_2019].
#
#---
## Species richness to community attributes 
#---
#
#To reveal the mechanisms behind the relationship between species richness and
#biomass stability, causal links were set from species richness to other
#community attributes. In particular, species richness decreased connectance
#following results from @thebault_stability_2010; @winemiller_must_1989. But
#theoretically, some ecological networks can show the inverse relationship
#[@winemiller_must_1989]. (6) We hypothesized also that species richness will
#modulate average weighted trophic level because of food web assembly processes.
#A community with more fish species can support higher trophic level. Finally, we
#set up causal relationships from community attributes to stability components. 
#
#---
##  Community attributes to stability
#---
#We hypothesized that (7) species richness decreased synchrony between species
#[@loreau_species_2008] and increased $\overline{CV_{sp}}$
#[@tilman_biodiversity_2006]. (8a) We expected that average trophic level had a
#positive or negative relationship with synchrony, bottom-up effects should
#result in positive whereas top-down in negative relationships. We expected a (8b)
#negative relationship between average trophic level and $\overline{CV_{sp}}$ if
#predators stabilised prey fluctuations or if the increasing part of
#biomass in the predators decreased $\overline{CV_{sp}}$ because of their higher
#body mass (if mean increase faster than variance). (9a) Connectance was expected
#to decrease or increase $\overline{CV_{sp}}$ and (9b) synchrony because of top
#down effects or bottom up effects.
---



```{r, cache = FALSE}
hist_var_caption <- paste0(
  "Distribution of the variables included in the Structural Equation Models. The
  biomass stability, the CV of species (CVsp), PCA1, PCA2, species richness,
  synchrony and total biomass were logged. See Table S5 for the units."
)
```

```{r hist-sem-data, cache = FALSE, fig.cap = hist_var_caption}
sem_data %>%
  select(log_bm_std, log_rich_tot_std, log_sync, log_stab_std, log_cv_sp, log_RC1, log_RC2, t_lvl, ct) %>%
  gather(variable, value) %>%
  mutate(variable = str_replace_all(variable, get_sem_var_name_replacement())) %>%
  ggplot(aes(x = value)) +
  labs(y = "Values", x = "Frequency") +
  geom_histogram() +
  facet_wrap(~variable, scales = "free")
```


```{r, cache = FALSE}
colin_sem_cap <- paste0(
  "Variance Inflation Factor for each individual linear model of the structural
  equation models."
) 
```


```{r s-colin-sem, fig.cap = ""}
mod_stab_list <-
  list(
    nlme::lme(log_rich_tot_std ~ log_RC1 + log_RC2,  random = ~ 1 | basin, data = sem_data),
    nlme::lme(ct ~ log_RC1 + log_RC2 + log_rich_tot_std, random = ~ 1 | basin, data = sem_data),
    nlme::lme(t_lvl ~ log_RC1 + log_RC2 + log_rich_tot_std, random = ~ 1 | basin, data = sem_data),
    nlme::lme(log_sync ~ log_rich_tot_std + ct + t_lvl + log_RC1 + log_RC2,
      random = ~ 1 | basin, data = sem_data),
    nlme::lme(log_cv_sp ~ log_rich_tot_std  + ct + t_lvl
      + log_RC1 + log_RC2, random = ~ 1 | basin, data = sem_data),
    lm(log_stab_std ~ log_cv_sp + log_sync, data = sem_data),
    nlme::lme(log_bm_std ~ log_rich_tot_std  + ct + t_lvl
      + log_RC1 + log_RC2, random = ~ 1 | basin, data = sem_data)
  )
names(mod_stab_list) <- c(
  "Species richness",
  "Connectance",
  "Avg trophic level",
  "Synchrony",
  "CVsp",
  "Biomass stability",
  "Total biomass"
) 

colin_stab_sem <- map(mod_stab_list, car::vif)

tmp <- map(colin_stab_sem, enframe)
  
# colinearity table
colin_stab_sem <- tibble(vif = tmp, mod = names(mod_stab_list)) %>%
  unnest(vif) %>%
  rename(`Response variable` = mod) %>%
  mutate(
    value = round(value, 1),
    name = str_replace_all(name, get_sem_var_name_replacement())
    ) %>%
  spread(name, value)

```

```{r, cache = FALSE}
kable(colin_stab_sem,
  format = "latex",
  booktabs = T,
  caption = "Variance Inflation Factor for the linear models used in the structural
  equation models. NA values indicate that the term in column was not included
  in the modeling of the response variable in row."
  ) %>%
kable_styling(latex_options = c("striped", "scale_down"))
```


```{r, cache = FALSE}
caption_mod_res <- paste0(
  "Residuals versus fitted values of the linear models included in the structural
  equation models."
) 
```

```{r mod-res, fig.width = 7, fig.asp = 2, fig.cap = caption_mod_res, cache = FALSE}
library(nlme)
plot_lme_residuals <- function (x = NULL, main = NULL) {
  if (is.matrix(x$residuals)) {
    tb <- tibble(
      resid = x$residuals[, "fixed"], 
      fitted = x$fitted[, "fixed"]
    )
  } else {
    tb <- tibble(
      resid = x$residuals, 
      fitted = x$fitted
    )
  }

  ggplot(tb, aes(y = resid, x = fitted)) +
    geom_point() +
    labs(x = "Fitted values", y = "Residuals", title = main)

}
p_resid_stab_sem <- map2(mod_stab_list, names(mod_stab_list) , plot_lme_residuals)
plot_grid(plotlist = p_resid_stab_sem, ncol = 2)
```

```{r}
format_coef_table <- function (sem = NULL) {

  params <- sem$coefficients[, -length(colnames(sem$coefficients))]
  #colnames(params)[length(colnames(params))] <- "Stars"

  replace_wo_n <- str_replace_all(get_sem_var_name_replacement(), "\n", "")
  names(replace_wo_n) <- names(get_sem_var_name_replacement()) 

  params %<>%
    mutate_at(c("Response", "Predictor"),
      ~str_replace_all(., replace_wo_n))

  params
}
```

```{r, cache = FALSE}
est_stab_sem_caption <- paste0(
  "Estimates of the effects of the studied variables as predicted by the
  structural equation model on the temporal stability of annual community
  biomass. Avg: Average, Sdt.Error: Standard Error, DF: Degree of Freedom,
  P.Value: P-value, Std.Estimate: Standardised
  estimate. Significant standardised estimates are in bold."

)
format_coef_table(stab_sem_rich) %>%
  select(-Crit.Value) %>%
  mutate_if(is.numeric, round, digits = 2) %>%
  mutate(Std.Estimate = cell_spec(Std.Estimate, bold = ifelse(P.Value <= 0.05,
	T, F), format = "latex", escape = F)
    ) %>%
kable(
  format = "latex",
  booktabs = T,
  caption = est_stab_sem_caption,
  escape = F,
  digits = 2
  ) %>%
collapse_rows(columns = 1, valign = "top") %>%
kable_styling(latex_options = c("striped", "scale_down"))
```

```{r, cache = FALSE}
est_bm_sem_caption <- paste0(
    "Estimates of the effects of the studied variables as predicted by the
  structural equation model on the median of annual community
  biomass. Avg: Average, Sdt.Error: Standard Error, DF: Degree of Freedom,
  P.Value: P-value, Std.Estimate: Standardised
  estimate. Significant standardised estimates are in bold."
)

format_coef_table(bm_sem_rich) %>%
  select(-Crit.Value) %>%
  mutate_if(is.numeric, round, digits = 2) %>%
  mutate(Std.Estimate = cell_spec(Std.Estimate, bold = ifelse(P.Value <= 0.05, T, F))) %>%
kable(
  format = "latex",
  booktabs = T,
  caption = est_bm_sem_caption,
  escape = F, 
  digits = 2
  ) %>%
collapse_rows(columns = 1, valign = "top") %>%
kable_styling(latex_options = c("striped", "scale_down"))
```

```{r rsq-model}
rm_n <- str_remove_all(get_sem_var_name_replacement(), pattern = "\n")
names(rm_n) <- names(get_sem_var_name_replacement()) 
rsq_table <- map_dfr(mod_stab_list, piecewiseSEM::rsquared, method = "nagelkerke") %>%
  mutate_at(vars(Conditional, Marginal), ~round(., 2)) %>%
  mutate(Response = str_replace_all(Response, rm_n)) %>%
  dplyr::select(Response, Marginal, Conditional, R.squared)
rsq_table_caption <- paste0(
  "R squared of the linear models used in the structural equation modeling."
)
```



```{r tab-coeff-bm, fig.cap = "Coefficient"}
# Replacement rules for term
rp_est <- c(
  "(Intercept)" =     "intercept",
  "sd\\_\\(intercept\\)\\.basin" = "sd intercept basin",
  "log_rich" =     "Median richness (log base 10)",
  "troph_group3" =     "high trophic group",
  "log_rich:troph_group3" =     "Median richness (log10) : high trophic group",
  "sig01.basin" =     "sd intercept basin",
  "sd_Observation.Residual" =     "residuals",
  "sigma" = "residuals"
)
# Replacement rules for group
rp_group <- c(
  "fixed" = "Fixed",
  "basin" = "Random"
)
```

```{r}
mask_drop_lm <- names(mod_stab_list) %in% "Biomass stability"
random_coeff_sem <- map(mod_stab_list[!mask_drop_lm], random.effects)
test <- getVarCov(mod_stab_list[!mask_drop_lm][[2]])

# get random effect 
get_intercept_variance <- function (mod) {
  vc <- VarCorr(mod)
  suppressWarnings(storage.mode(vc) <- "numeric")
  enframe(vc[1,])
}
random_coeff_sem <- map(mod_stab_list[!mask_drop_lm],
  get_intercept_variance) %>%
  enframe(name = "variable") %>%
  unnest(value) %>%
  pivot_wider(names_from = "name", values_from = "value")
#check
#all.equal(random_coeff_sem[[2]],(random_coeff_sem[[3]])^2)
#good

# get intercept 
get_intercept <- function (mod) {
  mod[["coefficients"]]$fixed["(Intercept)"]
}
intercept_sem <- map_dbl(
  mod_stab_list[!mask_drop_lm], get_intercept) %>%
  enframe(name = "variable", value = "Intercept")

formated_random_effects <- intercept_sem %>% 
  left_join(random_coeff_sem, by = "variable") %>%
  rename(`Response variable` = variable)
caption_random_effect <- paste0(
  "Random effect estimation from the linear models. This was set as a random
  effect of the hydrographic basins on the intercept.")

kable(formated_random_effects,
  format = "latex",
  booktabs = T,
  digits = 2,
  caption = caption_random_effect
  ) %>%
kable_styling(latex_options = c("striped"))
```

```{r sensitivity, cache = TRUE, message = FALSE, fig.dim = c(10, 7), fig.cap = "Sensivity analysis with different dataset"}
library(furrr)

myload(op_analysis, op_analysis_wo_holes, op_analysis_ov, dir = mypath("data"))
myload(biomass_ts_sax, dir = mypath("data"))
op_analysis_bbb <- filter(op_analysis, station %in%
  biomass_ts_sax[biomass_ts_sax$sax == "bbb",]$station)
op_analysis_wo_holes_bbb <- filter(op_analysis_wo_holes, station %in%
  biomass_ts_sax[biomass_ts_sax$sax == "bbb",]$station)

myload(network_metrics, dir = mypath("data", "classes"))
sem_sensivity_data <- list(full = op_analysis, bbb = op_analysis_bbb,
  without_holes = op_analysis_wo_holes, bbb_without_holes = op_analysis_wo_holes_bbb)

sem_stab_l_data <- 
  furrr::future_map(sem_sensivity_data,
    ~build_dataset_get_sem_coefficient(
      .op = .x,
      sem_fun = compute_stab_sem_rich
    )
  )

nb_station <- map_int(sem_sensivity_data, ~length(unique(.x$station))) 

sem_stab_results <- map(sem_stab_l_data,
  ~.x$coefficients[-ncol(.x$coefficients)]) %>%
  enframe() %>%
  rename(dataset = name) %>%
  unnest(value)

# Reformat
colnames(sem_stab_results) <- str_to_lower(colnames(sem_stab_results))
mysave(sem_stab_results, dir = mypath("data"), overwrite = TRUE)
```

```{r sem-sens-bm, fig.cap = "Sensivity analysis for Biomass"}
sem_bm_l_data <- furrr::future_map(sem_sensivity_data,
  ~build_dataset_get_sem_coefficient(
    .op = .x,
    sem_fun = compute_prod_sem_rich)
)
sem_bm_results <- map(sem_bm_l_data,
  ~.x$coefficients[-ncol(.x$coefficients)]) %>%
  enframe() %>%
  rename(dataset = name) %>%
  unnest(value)

# Reformat
colnames(sem_bm_results) <- str_to_lower(colnames(sem_bm_results))
mysave(sem_bm_results, dir = mypath("data"), overwrite = TRUE)
```

```{r}
sens_cap <- paste0(
  "Sensivity analysis of the Structural Equation models for total biomass
  and its temporal stability."," The Constant dataset is the one keeping only the
  sites that does not show a clear temporal trend of community biomass; ", "Constant/
    without holes dataset kept only the constant sites plus the ones that had no
  holes in their sampling period; ", "Complete is the dataset containing all the
  sites that have been followed ten years or more;", " Without holes dataset is
  the complete dataset but containing only the sites that had no holes in their sampling period."
)
```


```{r, fig.height = 8, fig.cap = sens_cap}
p_sens_bm <- plot_sensivity_analysis(
  .data = sem_bm_results,
  inverse_label_order = TRUE) +
  labs(x = "", title = "Median of annual community biomass") +
  theme(legend.position = "none", plot.margin = unit(c(0, 0, 0, 25), units = "mm"))

p_sens_stab <- plot_sensivity_analysis(.data = sem_stab_results,
  inverse_label_order = TRUE) +
  labs(title = "Temporal stability of annual community biomass") +
  guides(color = guide_legend(direction = "horizontal", nrow = 2))
legend_b <- get_legend(p_sens_stab)
p_sens_stab %<>% + theme(legend.position = "none", plot.margin = unit(c(0,0,0,27), units = "mm"))
p <- plot_grid(
  p_sens_bm, p_sens_stab, legend_b, nrow = 3,
  rel_heights = c(1, 1, .1)
  #,
  #labels = c("Total biomass", "Biomass stability")
)
p
```

```{=latex}
\pagebreak
```


# References

