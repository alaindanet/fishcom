# Methods

We describe our methods in this chapter.

## Describe datasets

### Community and network datas

- \*\_analysis (data in general by species and fishing operation):
  - community_analysis:
    - by species and by fishing operation:
      - number of individuals
      - mean length   
      - sum of biomass
  - network_analysis:
    - by fishing operation:
      - data:
	-length, class and species of each individual
      - network:
	- feeding link between species in the igraph::graph_from_data_frame()
	  format
	- from to: the "from" is eaten by "to", i.e. the biomass goes "from" "to"
      - composition (by opcod and by species):
	- troph_level: trophic level of the species
	- biomass: species biomass
	- troph_group: high (group 3) or low predator (group 2)

- \*\_metrics (metrics by fishing operation):
  - community_metrics:
    - richness: species richness
    - nind: number of individuals
    - biomass: sum of biomass
    - sp_vector: named vector of species biomass (name corresponding to species)
    - rel_bm: named vector of relative species biomass (name corresponding to species)
    - pielou: pielou index on biomass distribution of species
    - simpson: simpson index on biomass distribution of species
  - network_metrics:
    - from data to troph_group: see network_analysis
    - nestedness: network index
    - modul_guimera: guimera modularity index
    - diet_overlap: matrix of diet overlap between species pair 
    - avg_diet_overlap: mean diet overlap between species pair
    - connectance: network index 
    - nbnode: nb of nodes in the network (i.e. species or species classes plus
      resources as detrivor, zooplankton, phytoplankton)
    - compartiment: compartimentation index of the network 
    - troph_level_avg: mean trophic level of the network  
    - troph_length: trophic length of the network
    - modularity: modeularity of the network
    - connectance_corrected: residuals of the relationship between connectance
      and nbnode
    - modularity_corrected: cf above
    - troph_level_avg_corrected: cf above 
    - mean_troph_level_corrected: cf above
    - w_trph_lvl_avg: mean trophic level of the network WEIGHTED by biomass


- temporal\_\*\_metrics (metrics summarised by station):
  - temporal_community_metrics (cf community_metrics for the index):
    - \*\_avg: mean of the index  
    - \*\_cv: cv of the index
    - \*\_med: median of the index 
    - \*\_stab: stab of the index (i.e. 1/cv)
    - betadiv\_\*: $\beta$-diversity 
      - betadiv: mean dissimilarity between year for species composition
      - \*\_bin: binary species composition (0 or 1)
      - \*\_diag: dissimilarity between year to year (diagonal of the
	dissimilarity matrix)
  - temporal_network_metrics (cf network_metrics for the index):
    - same principle than for temporal_community_metrics
    - troph_group

### Station data

- op_analysis:
  - protocol_type: type of fishing (complete or partial)
  - opcod: id of the fishing operation
  - date: date (YYYY-MM-DD) of the fishing operation
  - station: id of the station
  - protocol: protocole name (complete, partial_by_point, partial_over_bank)
  - surface: surface sampled
  - nb_sp: number of the species sampled for the fishing operation
  - nb_ind: number of the individuals sampled for the fishing operation
  - year: year at which the fishing operation was done  
  - length_sourced: length of river fished

## Data collection


### Fish length

```{r, fig.dim = c(4, 4), fig.cap = "Distribution of fish length. Red, green and black respectively locate the median, the mean and the 200mm threshold."}
myload(length_analysis, dir = mypath("data"))
length_analysis %>%
  ggplot(aes(x = length)) +
  geom_histogram() +
  geom_vline(xintercept = median(length_analysis$length, na.rm = TRUE), color = "red") +
  geom_vline(xintercept = mean(length_analysis$length, na.rm = TRUE), color = "green") +
  geom_vline(xintercept = 200, color = "black")
```



## Network building

- A metaweb was built:
  - less computational intensive

When you do a metaweb, you kind of consider that you have one type of community
in terms of species interaction:
  - Trophic lvl is defined at the metaweb lvl, different from the realized
    metaweb


### Metaweb


```{r metaweb, fig.cap = "Metaweb representation (9 classes by fish species)"}
library(igraph)
library(NetIndices)
myload(metaweb_analysis, dir = data_common)
meta <- metaweb_analysis; rm(metaweb_analysis)

g <- igraph::graph_from_adjacency_matrix(meta$metaweb, mode = "directed")

# Define layout
lay <- layout.fruchterman.reingold(g)
# Compute trophic level
dead_material <- c("det", "biof")
lay[, 2] <- TrophInd(meta$metaweb, Dead = dead_material)$TL
# Plot
par(mar=rep(5, 4))
plot.igraph(g,layout=lay,vertex.label=NA,vertex.size=2,edge.arrow.size=.5,edge.width=.5)
```

### Local networks 

OMG, that is bautiful!

```{r local-net, fig.cap = "An exemple of a local network"}
myload(network_analysis, dir = mypath("data", "species"))
myload(op_analysis, dir = data_common)
net <- network_analysis %>%
  dplyr::select(opcod, network) %>%
  unnest() %>%
  left_join(., dplyr::select(op_analysis, opcod, station, date)) 

net_ex <- filter(net, station == unique(net$station) %>% sample(., 1))

net_list <- net_ex %>%
  dplyr::select(date, from, to) %>%
  arrange(date) %>%
  group_by(date) %>%
  nest(.key = "network")

size_analysis <- network_analysis %>%
  dplyr::select(opcod, composition) %>%
  filter(opcod %in% net_ex$opcod) %>%
  unnest() %>%
  left_join(select(net_ex, date, opcod) %>% distinct(opcod, date)) %>%
  dplyr::select(date, biomass, species) %>%
  arrange(date) %>%
  group_by(date) %>%
  nest() %>%
  mutate(biomass = map(data, function(x){
      val <- x$biomass
      names(val) <- x$species 
      val
  }))

net_list %<>%
  left_join(dplyr::select(size_analysis, date, biomass))
#Node position:
node <- net_list$network %>% unlist(., use.names = FALSE) %>% unique
test <- graph_from_adjacency_matrix(meta$metaweb) %>%
  igraph::as_data_frame(.) %>%
  mutate_all(list(~str_extract_all(., "[a-zA-Z]+", simplify = TRUE))) %>%
  distinct(from, to)
node_position <- create_layout(graph_from_data_frame(test), layout = "kk")$x
names(node_position) <- create_layout(graph_from_data_frame(test), layout = "kk")$name
#color:
color <- set_color_species(node_list = node, species_list = NULL,
  resource_list = NULL,
  col_resource = NULL)

## Graph -------------------------
plot_temporal_network(
  data = net_list,
  net_var = network,
  date = date,
  x = node_position,
  y = net_list[["y"]],
  size = net_list[["biomass"]]
)

```

This is super cool to see! =)

### Network caracteristics  

```{r}
myload(temporal_network_metrics, dir = mypath("data", "classes"))
temporal_network_metrics_classes <- temporal_network_metrics
myload(temporal_network_metrics, dir = dest_dir)
myload(temporal_community_metrics, synchrony, dir = data_common)
```

```{r net-cor-med, fig.cap = "Correlation between network indices (median over the temporal series). "}
# Get network metrics


cor_avg <- temporal_network_metrics %>%
  select_at(vars(dplyr::matches("med"))) %>%
  na.omit %>%
  cor(., method = "spearman")
#knitr::kable(cor_avg)
as.data.frame(round(cor_avg,2)) %>%
  mutate_all(funs(cell_spec(., "html", color = ifelse(abs(.) > .65 & . != 1, "red",
	  "black")))) %>%
  mutate(variable = colnames(.)) %>%
  select(variable, everything()) %>%
  kable(format = "html", escape = F) %>%
  kable_styling() %>%
  scroll_box(width = "100%", height = "400px")
```

```{r net-cor-cv, fig.cap="Correlation between network indices (CV over the temporal series). "}
cor_cv <- temporal_network_metrics %>%
  select_at(vars(dplyr::matches("cv"))) %>%
  na.omit %>%
  cor(., method = "spearman")

as.data.frame(round(cor_cv,2)) %>%
  mutate_all(funs(cell_spec(., "html", color = ifelse(abs(.) > .65 & . != 1, "red",
	  "black")))) %>%
  mutate(variable = colnames(.)) %>%
  select(variable, everything()) %>%
  kable(format = "html", escape = F) %>%
  kable_styling() %>%
  scroll_box(width = "100%", height = "400px")

```

```{r}
library(ade4)
library(factoextra)

net_ind <- temporal_network_metrics %>%
  left_join(select(temporal_community_metrics, station, richness_med)) %>%
  select_at(vars(dplyr::matches("med")))

res.pca <- dudi.pca(na.omit(net_ind),
  scannf = FALSE,   # Hide scree plot
  nf = 5            # Number of components kept in the results
)
eig_plot <- fviz_eig(res.pca)
```

```{r}
pca_plot <- lapply(list(c(1,2), c(1, 3), c(3, 2)), function (axes) {
  fviz_pca_var(res.pca,
    axes = axes,
    col.var = "contrib", # Color by contributions to the PC
    gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"),
    repel = TRUE     # Avoid text overlapping
  )
})

plot_grid(eig_plot, pca_plot[[1]], pca_plot[[2]], pca_plot[[3]], labels =
  "AUTO")
```

## Fishing methods

```{r}
myload(env_analysis, biomass_ts_sax, dir = data_common)
```


```{r}
census <- op_analysis %>%
  left_join(select(env_analysis, station, opcod, width_river))

census %>%
  ggplot(aes(y = length_sourced, x = width_river, color = protocol_type)) +
  scale_x_log10() +
  scale_y_log10() +
  geom_point()
```

```{r}
census %>%
  group_by(station) %>%
  arrange(year) %>%
  nest()
bm_census <-  biomass_ts_sax %>%
  unnest(data) %>%
  left_join(mutate(census, station = as.character(station)),
    by = c("station", "date"))
```

```{r}
# Test how sampled effort is linked to biomass
mod_bm_census <- bm_census %>%
  group_by(station, protocol_type) %>%
  #mutate(biomass = scale(biomass)) %>%
  nest() %>%
  filter(!is.na(station)) %>%
  mutate(
    mod_w_l = map(data, ~lm(length_sourced ~ width_river, data = .x)),
    data_w_l = map(mod_w_l, broom::augment),
    data_resid = map2(data, data_w_l,
      function(raw, augmented) {
	raw$resid_length <- augmented[[".resid"]]
        return(raw)
      }),
    model = map(data_resid, ~lm(biomass ~ resid_length, data = .x)),
    coeff = map(model, broom::tidy),
    summary = map(model, broom::glance)
  )

mod_bm_census %>%
  unnest(coeff) %>%
  #rename(interp = `(Intercept)`, slope = length_sourced) %>%
  filter(! term %in% "(Intercept)") %>%
  mutate(effect_size = estimate / std.error) %>%
  #select(station, term, estimate) %>%
  #spread(term, estimate) %>%
  ggplot(aes(x = estimate)) +
  geom_histogram() +
  geom_vline(aes(xintercept = mean(estimate)))

```

```{r}

mod_bm_census %>%
  unnest(coeff) %>%
  filter(! term %in% "(Intercept)")

residuals(mod_bm_census$model[[9]])
mod_bm_census$model[[9]]
mod_bm_census$data[[9]]
```



## Environmental data


### Habitat

```{r}
myload(temporal_station_desc, temporal_press_polluants, dir = data_common)
myload(hab_analysis, geo_station, dir = data_common)

habitat_pressure <- build_habitat_pressure_dataset(
  .habitat_analysis = hab_analysis,
  .tmp_press = temporal_press_polluants,
  .tmp_st_desc = temporal_station_desc,
  .geo_st = geo_station 
)
```

```{r}
st_basin <- get_basin_station(sf_obj = TRUE) 

st_basin %>%
  ggplot() +
  geom_sf(aes(fill = basin, color = basin))
#myload(region_polygon, dir = mypath("data"))
```


### Relationship between environmental variables

```{r, fig.cap = "Spearman correlation between environmental variables."}
m <- cor(as.matrix(select(na.omit(habitat_pressure), -station)), method = "spearman")
corrplot::corrplot(m, order="hclust", type = "upper", diag = FALSE)
```

```{r pca-hab, fig.dim = c(10, 7), fig.cap = "PCA over habitat description"}
library(ade4)
library(factoextra)
pca_hab <- dudi.pca(as.data.frame(select(na.omit(habitat_pressure), -station)), scannf = FALSE, nf = 3, center = TRUE, scale = TRUE)

eig_plot <- fviz_eig(pca_hab)
pca_plot <- fviz_pca_var(pca_hab,
    axes = c(1, 2),
    col.var = "contrib", # Color by contributions to the PC
    gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"),
    repel = TRUE     # Avoid text overlapping
  )
pca_plot12 <- ggdraw(pca_plot) +
  draw_plot(eig_plot, x = .7, y = .95, hjust = 1, vjust = 1, width = 0.17, height = 0.25)

pca_plot13 <- fviz_pca_var(pca_hab,
    axes = c(1, 3),
    col.var = "contrib", # Color by contributions to the PC
    gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"),
    repel = TRUE     # Avoid text overlapping
  )

pca_plot23 <- fviz_pca_var(pca_hab,
    axes = c(2, 3),
    col.var = "contrib", # Color by contributions to the PC
    gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"),
    repel = TRUE     # Avoid text overlapping
  )
plot_grid(pca_plot12, pca_plot13, pca_plot23, ncol = 3)
```

The PCA (Fig. \@ref(fig:pca-hab)) showed unsurprisingly that order of strahler, the
depth, width of the river and distance to source and avg flow are closely
linked. Altitude, slope and the amount of rocky shelter are also closely linked.
Station of larger latitude had also higher DBO and phosphorus, higher annual
mean temperature and more vegetation.  The first axis of the PCA (ordinate)
discriminated station located far from the source (which are large, deep, with a
big annual flow and high strahler order) from the shady station, which are
sinuous, with a variety of habitat such as under bank and logjam.
The second axis (abscissa) discriminated station in altitude with high slope,
composed of rocky habitat from the ones that had higher average annual
temperature located in the south, with more enrichment (DBO, nitrates,
phosphorus) and that are more vegetated.


```{r, fig.show = "hide"}
evt_var_mean <- c("flow_med", "temperature_med", "width_river_mean",
  "avg_depth_station_mean", "slope", "alt", "d_source", "strahler", "DBO_med")
evt_var_cv <- c("flow_cv", "temperature_cv", "width_river_cv",
  "avg_depth_station_cv", "DBO_cv")
pca_pressure <- habitat_pressure[, names(habitat_pressure) %in% c(evt_var_mean, evt_var_cv, "station")] %>%
  na.omit

pca_rotated <- compute_rotated_pca(
  .data = pca_pressure[, !names(pca_pressure) %in% "station"],
  naxis = 5 
)

axis_pair <- list(c(1,2), c(1,3), c(2,3), c(1, 4), c(2, 4), c(3,4), c(4,5))
p_l_rot <- map(axis_pair, 
  function (axis)
    pca_rotated_plot <- plot_rotated_pca(
      pca_rotated = pca_rotated,
      axis = axis 
    )
)
```

```{r}
to_plot <- c(1, 6, 7)
plot_grid(plotlist = c(
    map(p_l_rot[to_plot], ~.x$rotated),
    map(p_l_rot[to_plot], ~.x$normal)
    ), ncol = length(to_plot), rel_height = c(.4, .6))
```



```{r add pca axis to habitat pressure}

test <- pca_rotated$rotated$scores
rotated_axis_st <- cbind(pca_pressure[, "station"], test) 

habitat_pressure %<>%
  left_join(rotated_axis_st, by = "station")

mysave(habitat_pressure, pca_pressure, dir = mypath("report"), overwrite = TRUE)
```



#### Distribution of environmental variables

```{r dist-env, fig.cap = "Histogram of the station average environmental values through time."}
dist_env <- habitat_pressure %>%
  select(station, width_river_mean:temperature_cv) %>%
  gather(env_var, value, width_river_mean:temperature_cv) 
med_dist_env <- dist_env %>%
  group_by(env_var) %>%
  summarise(value = median(value, na.rm = TRUE))

dist_env %>%
  ggplot(aes(x = value)) +
  geom_histogram() +
  geom_vline(data = med_dist_env, aes(xintercept = value), color = "red", size =
    2) +
  facet_wrap(facets = ~ env_var, ncol = 3, scales = "free")

```


The figure \@ref[fig:dist-env] shows that, taking the environmental values one
by one, there was no apparent bimodality for habitat description such as
altitude, slope, distance from source, strahler order, river width and depth, flow, temperature.
However, variables such as latitude, insecticides, fungicides, herbicides
displayed bimodality. Those bimodalities will be helpful to test relationship
between stability and diversity for different subset of the dataset and so, test
the robustness of the relationship.

```{r split-rivers, fig.dim = c(4, 4)}
hab_type <- habitat_pressure %>%
  mutate(high_bin = ifelse(alt > median(alt), TRUE, FALSE),
  wide_bin = ifelse(width_river_mean > median(width_river_mean), TRUE, FALSE),
  hab_type = map2_chr(high_bin, wide_bin, function(high, wide){
    if (high) {
      if (wide) {
	"high_wide"
      } else {
	"high_narrow"
      }
    } else {
      if (wide) {
	"low_wide"
      } else {
	"low_narrow"
      }
    }
      
      })
  ) %>%
  mutate(hab_type = map_chr(high_bin, ~ifelse(.x, "high", "low"))) %>%
  select(station, hab_type)

#plot_grid(pca_cat_river, ncol = 1)
mysave(hab_type, dir = mypath("report"), overwrite = TRUE)
```

### Pressure


#### Press category


```{r press-units, fig.cap = "All the parameters collected together with their units"}
# Put units to present all the parameters
myload(polluant_units, dir = mypath("data-raw", "polluants", "naiades_data"))
kable(polluant_units) %>%
  kable_styling() %>%
  scroll_box(width = "100%", height = "400px")
```

```{r press-cat, fig.cap = "Molecules of pressure by category together with their toxicity if relevant or available"}
myload(press_cat, dir = mypath("data-raw", "polluants"))
kable(arrange(press_cat, category)) %>%
  kable_styling() %>%
  scroll_box(width = "100%", height = "400px")
```


#### Press trough time


```{r press-time, fig.cap = "Average press category over the station through time. The pesticides are expressed in Toxic Unit (TU)."}
myload(press_metrics, dir = mypath("data"))
ggplot(press_metrics, aes(y = press, x = year)) +
  stat_summary(fun.y = "mean", geom = "line") +
  stat_summary(geom="ribbon", fun.data=mean_cl_normal, colour=NA,alpha=0.1)+
  facet_wrap(~category, scales = "free_y")
```

Most of the pressure decreased through time expect notably the nitrates and the
temperature (Fig. \@ref(fig:press-time)). **Be careful, there are certainly a
biais in temperature increase because the number of station that have been
sampled. It would be nice to look at the tendency by station.**


## Analysis

### Community 

Community composition were analyzed thanks to [NMDS](https://jonlefcheck.net/2012/10/24/nmds-tutorial-in-r/). 

```{r}
myload(community_metrics, temporal_community_metrics, synchrony, op_analysis, dir = data_common)
myload(community_analysis, dir = data_common)
myload(network_analysis, dir = mypath("data", "classes"))
myload(habitat_pressure, dir = mypath("report"))
```


```{r, fig.dim = c(7, 5), fig.cap = "NMDS on species composition."}
library(vegan)

myload(nmds, com_mat, dir = mypath("report"))


order_st <- match(temporal_community_metrics$station, com_mat$station) 
tps_com_met <- temporal_community_metrics[order(order_st),] 
 
par(mfrow = c(1, 2))
stressplot(nmds)
title("Stress plot")
bluefunc <- colorRampPalette(c("lightyellow", "darkred"))
ordiplot(nmds,type="n")
orditorp(nmds,display="species",col="gray",air=0.01)
orditorp(nmds, display="sites",
  col= bluefunc(15)[findInterval(tps_com_met$richness_avg, seq(1,15))],
   cex = findInterval(log10(tps_com_met$biomass_med), seq(1, 4, 1))/2,
  air=0.01, pch = "+", labels = "+")
title("Color = species richness; Size of points = biomass")
```

```{r}
# Add habitat
habitat_press  <- filter(habitat_pressure, station %in% com_mat$station)
match_st <- match(habitat_press$station, com_mat$station)
habitat <- habitat_press[order(match_st), ]
match_st_com <- match(temporal_community_metrics$station, com_mat$station)
com_metrics <- temporal_community_metrics[order(match_st_com), ]
```

```{r, fig.dim = c(7, 14)}
hab_var <- c("temperature_med", "temperature_cv", "alt", "lat", "flow_med", "flow_cv", "width_river_mean", "width_river_cv", "DBO_med", "DBO_cv")
par(mfrow = c(5,2))
for (i in seq_along(hab_var)) {
  ordisurf(nmds, habitat[[hab_var[i]]], main = hab_var[i], col = "brown")
}
```

```{r}
com_var <- c("richness_med", "biomass_stab", "biomass_med")
par(mfrow = c(2,2))
for (i in seq_along(com_var)) {
  ordisurf(nmds, com_metrics[[com_var[i]]], main = com_var[i], col =
    "forestgreen")
}
```

```{r basin-st}
station_analysis <- get_basin_station(sf_obj = TRUE) %>%
  filter(station %in% com_mat$station)

# How many station by basin:
nb_st_basin <- station_analysis %>%
  group_by(basin) %>%
  summarise(nobs = n())
```

```{r basin-com, fig.dim = c(7, 4), fig.cap = "Species composition by group (95% ellipse)"}
match_st_basin <- match(station_analysis$station, com_mat$station)
st_basin <- 
  station_analysis[order(match_st_basin), ] %>%
  mutate(basin = ifelse(is.na(basin), "INCONNU", basin))

par(mfrow = c(1,2))

ordiplot(nmds,type="n")
orditorp(nmds,display="species",col="red",air=0.01)
title("Composition by basin")
# See https://www.davidzeleny.net/anadat-r/doku.php/en:ordiagrams_examples
u_basin  <- unique(st_basin[["basin"]])
for (i in seq_along(u_basin)) {
  ordiellipse(nmds, groups = st_basin[["basin"]],
 show.group = u_basin[i], col = i, draw = 'polygon', label = T)
}

tmp_hab_type <- filter(hab_type, station %in% com_mat$station)
match_st <- match(tmp_hab_type$station, com_mat$station)
tmp_hab_type <- tmp_hab_type[order(match_st), ]
ordiplot(nmds,type="points", choices = c(1, 2))
orditorp(nmds,display="species",col="red",air=0.01)
title("Composition by Low / High altitude")
u_hab  <- unique(tmp_hab_type[["hab_type"]])
for (i in seq_along(u_hab)) {
  ordiellipse(nmds, groups = tmp_hab_type[["hab_type"]], alpha = .3,
 show.group = u_hab[i], col = i, draw = 'polygon', label = T)
}
```

#### Species occurrence

```{r sp-occ}
myload(community_analysis, dir = data_common)

com <- community_analysis %>%
  dplyr::select(opcod, species, biomass) %>%
  dplyr::left_join(op_analysis[, c("opcod", "station")], by = "opcod") %>%
  dplyr::filter(!is.na(station)) %>%
  dplyr::group_by(station) %>%
  tidyr::nest() %>%
  mutate(data = map(data, function (.data) {
      .data %<>%
	tidyr::spread(species, biomass) %>%
	dplyr::select(-opcod) %>%
	dplyr::mutate_all(list(~ ifelse(is.na(.), 0, .))) %>%
	dplyr::summarise_all(list(~ sum(. != 0) / n()))
      return(.data)
      }
    )
  )

# Local med occurence
occurence_sp_st <- com %>%
  unnest() 

global_med_occ <- occurence_sp_st %>%
  dplyr::summarise_if(is.double, list(~median(., na.rm = TRUE))) %>%
  gather(sp, med_occ, everything()) 

p_global_med_occ <- global_med_occ %>%
  ggplot(aes(x = med_occ)) +
  geom_histogram() +
  labs(x = "Median occurrence of species in station")


mysave(occurence_sp_st, dir = mypath("report"), overwrite = TRUE)
```



#### Description of horizontal Community structure 

- Pielou computed on biomass:
  - pielou does not depend on total biomass (same value if computed on raw
    biomass or relattive biomass)

- Binary betadiversity computed on biomass:
  - betadiversity-bin is the same if computed on biomass or individual number 
  - betadiversity-bin computed on biomass is correlated at .72 with the one
    computed with individual numbers.

- Species richness

### Network

### Stability

#### Species contribution

The species contribution to CV and synchrony have been computed, to identify
which species are driving the relationship between CV and species richness.

Species contribution to a metric can be computed as follow:

$$
C_{k} = X - X_{-k}
$$

It means that a negative $C_k$ correspond to a negative contribution of the
species $k$ to $X$.


### Pressure


### Time series classification


```{r load dataset}
library(jmotif)
myload(community_metrics, op_analysis, dir = mypath("data"))
community_metrics  <-   
  left_join(community_metrics, op_analysis[, c("opcod", "station", "date")], by = "opcod")
```

```{r}
ts_biomass <- community_metrics %>%
  dplyr::select(station, date, biomass) %>%
  mutate(station = as.character(station)) %>%
  group_by(station) %>%
  arrange(date) %>%
  nest()

ts_biomass %<>%
  mutate(
    zts = map(data, function(x) znorm(x$biomass, threshold = 0.01)),
    paa = map(zts, ~paa(., 3)),
    sax = map_chr(paa, ~series_to_string(., 3))
  )

biomass_ts_sax <- ts_biomass 
mysave(biomass_ts_sax, dir = mypath("data"), overwrite = TRUE)
```


```{r}
pattern_dist <- ts_biomass %>%
  group_by(sax) %>%
  summarise(count = n()) %>%
  arrange(desc(count))
ggplot(ts_biomass, aes(x = sax)) +
  geom_histogram(stat = "count")
```

```{r}
test <- ts_biomass %>%
  filter(sax %in% c("cba", "bbb", "cab", "abc", "acb", "bca", "bac", "cbb")) %>%
  group_by(sax) %>%
  sample_n(10) %>%
  mutate(
    paa2 = map2(data, zts, function (x, zts) {
      cbind(x[,1], zts)
  }),
    id_sta = as.character(seq(1,n()))

  ) %>%
  unnest(paa2)

ggplot(test, aes(x = date, y = zts)) +
  geom_line(aes(color = id_sta)) +
  facet_wrap(~ sax)

```

```{r}
myload(polluant_units, dir = mypath("data-raw", "polluants", "naiades_data"))

myload(press_metrics, dir = mypath("data"))
press_year <- press_metrics %>%
  filter(category %in% c("fungicides", "herbicides", "insecticides", "DBO", "temperature"))

biomass <- community_metrics %>%
  mutate(
    year = lubridate::year(date),
    category = "biomass",
    press = biomass 
    ) %>%
  select(station, year, category, press)
press_biomass <- press_year %>%
  bind_rows(rename(biomass, id = station)) %>%
  na.omit()
```

```{r}
samp_station <- sample(unique(press_biomass$id), 10)
temp <- press_biomass %>%
  mutate(id = as.character(id)) %>%
  filter(id %in% samp_station)

ggplot(temp, aes(y = press, x = year)) +
  facet_wrap(~category, scales = "free_y") +
  geom_line(aes(color = id))

```
